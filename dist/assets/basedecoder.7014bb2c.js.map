{"version":3,"file":"basedecoder.7014bb2c.js","sources":["../../node_modules/.pnpm/geotiff@1.0.8/node_modules/geotiff/src/predictor.js","../../node_modules/.pnpm/geotiff@1.0.8/node_modules/geotiff/src/compression/basedecoder.js"],"sourcesContent":["function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n","import { applyPredictor } from '../predictor';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n"],"names":[],"mappings":"AAAA,WAAsB,EAAK,EAAQ,CACjC,GAAI,GAAS,EAAI,OAAS,EACtB,EAAS,EACb,EAAG,CACD,OAAS,GAAI,EAAQ,EAAI,EAAG,IAC1B,EAAI,EAAS,IAAW,EAAI,GAC5B,IAGF,GAAU,QACH,EAAS,GAGpB,WAAgC,EAAK,EAAQ,EAAgB,CAC3D,GAAI,GAAQ,EACR,EAAQ,EAAI,OAChB,KAAM,GAAK,EAAQ,EAEnB,KAAO,EAAQ,GAAQ,CACrB,OAAS,GAAI,EAAQ,EAAI,EAAG,EAAE,EAC5B,EAAI,EAAQ,IAAW,EAAI,GAC3B,EAAE,EAEJ,GAAS,EAGX,KAAM,GAAO,EAAI,QACjB,OAAS,GAAI,EAAG,EAAI,EAAI,EAAE,EACxB,OAAS,GAAI,EAAG,EAAI,EAAgB,EAAE,EACpC,EAAK,EAAiB,EAAK,GAAK,EAAO,GAAiB,EAAI,GAAK,EAAM,GAKtE,WAAwB,EAAO,EAAW,EAAO,EAAQ,EAC9D,EAAqB,CACrB,GAAI,CAAC,GAAa,IAAc,EAC9B,MAAO,GAGT,OAAS,GAAI,EAAG,EAAI,EAAc,OAAQ,EAAE,EAAG,CAC7C,GAAI,EAAc,GAAK,GAAM,EAC3B,KAAM,IAAI,OAAM,wEAElB,GAAI,EAAc,KAAO,EAAc,GACrC,KAAM,IAAI,OAAM,sEAIpB,KAAM,GAAiB,EAAc,GAAK,EACpC,EAAS,IAAwB,EAAI,EAAI,EAAc,OAE7D,OAAS,GAAI,EAAG,EAAI,GAEd,IAAI,EAAS,EAAQ,GAAkB,EAAM,YAFvB,EAAE,EAAG,CAK/B,GAAI,GACJ,GAAI,IAAc,EAAG,CACnB,OAAQ,EAAc,QACf,GACH,EAAM,GAAI,YACR,EAAO,EAAI,EAAS,EAAQ,EAAgB,EAAS,EAAQ,GAE/D,UACG,IACH,EAAM,GAAI,aACR,EAAO,EAAI,EAAS,EAAQ,EAAgB,EAAS,EAAQ,EAAiB,GAEhF,UACG,IACH,EAAM,GAAI,aACR,EAAO,EAAI,EAAS,EAAQ,EAAgB,EAAS,EAAQ,EAAiB,GAEhF,cAEA,KAAM,IAAI,OAAM,gCAAgC,EAAc,uBAElE,EAAa,EAAK,OACb,AAAI,KAAc,GACvB,GAAM,GAAI,YACR,EAAO,EAAI,EAAS,EAAQ,EAAgB,EAAS,EAAQ,GAE/D,EAAuB,EAAK,EAAQ,IAGxC,MAAO,GCpFM,OAAkB,MACzB,QAAO,EAAe,EAAQ,CAClC,KAAM,GAAU,KAAM,MAAK,YAAY,GACjC,EAAY,EAAc,WAAa,EAC7C,GAAI,IAAc,EAAG,CACnB,KAAM,GAAU,CAAC,EAAc,aACzB,EAAY,EAAU,EAAc,UAAY,EAAc,WAC9D,EAAa,EAAU,EAAc,WACzC,EAAc,cAAgB,EAAc,YAE9C,MAAO,GACL,EAAS,EAAW,EAAW,EAAY,EAAc,cACzD,EAAc,qBAGlB,MAAO"}