{"version":3,"file":"lzw.caf16eda.js","sources":["../../node_modules/.pnpm/geotiff@1.0.8/node_modules/geotiff/src/compression/lzw.js"],"sourcesContent":["import BaseDecoder from './basedecoder';\n\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\n\nfunction getByte(array, position, length) {\n  const d = position % 8;\n  const a = Math.floor(position / 8);\n  const de = 8 - d;\n  const ef = (position + length) - ((a + 1) * 8);\n  let fg = (8 * (a + 2)) - (position + length);\n  const dg = ((a + 2) * 8) - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n  chunk1 <<= (length - de);\n  let chunks = chunk1;\n  if (a + 1 < array.length) {\n    let chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, (length - dg));\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    const hi = ((a + 3) * 8) - (position + length);\n    const chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\n\nfunction appendReversed(dest, source) {\n  for (let i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\n\nfunction decompress(input) {\n  const dictionaryIndex = new Uint16Array(4093);\n  const dictionaryChar = new Uint8Array(4093);\n  for (let i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  let dictionaryLength = 258;\n  let byteLength = MIN_BITS;\n  let position = 0;\n\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    const byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    const rev = [];\n    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n      rev.push(dictionaryChar[i]);\n    }\n    return rev;\n  }\n\n  const result = [];\n  initDictionary();\n  const array = new Uint8Array(input);\n  let code = getNext(array);\n  let oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(`corrupted code at scanline ${code}`);\n      } else {\n        const val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      const val = getDictionaryReversed(code);\n      appendReversed(result, val);\n      addToDictionary(oldCode, val[val.length - 1]);\n      oldCode = code;\n    } else {\n      const oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n\n    if (dictionaryLength + 1 >= (2 ** byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\n\nexport default class LZWDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return decompress(buffer, false).buffer;\n  }\n}\n"],"names":[],"mappings":"8CAEA,KAAM,GAAW,EACX,EAAa,IACb,EAAW,IACX,EAAiB,GAEvB,WAAiB,EAAO,EAAU,EAAQ,CACxC,KAAM,GAAI,EAAW,EACf,EAAI,KAAK,MAAM,EAAW,GAC1B,EAAK,EAAI,EACT,EAAM,EAAW,EAAY,GAAI,GAAK,EAC5C,GAAI,GAAM,EAAK,GAAI,GAAO,GAAW,GACrC,KAAM,GAAO,GAAI,GAAK,EAAK,EAE3B,GADA,EAAK,KAAK,IAAI,EAAG,GACb,GAAK,EAAM,OACb,eAAQ,KAAK,6EACN,EAET,GAAI,GAAS,EAAM,GAAO,GAAM,GAAI,GAAM,EAC1C,IAAY,EAAS,EACrB,GAAI,GAAS,EACb,GAAI,EAAI,EAAI,EAAM,OAAQ,CACxB,GAAI,GAAS,EAAM,EAAI,KAAO,EAC9B,IAAW,KAAK,IAAI,EAAI,EAAS,GACjC,GAAU,EAEZ,GAAI,EAAK,GAAK,EAAI,EAAI,EAAM,OAAQ,CAClC,KAAM,GAAO,GAAI,GAAK,EAAM,GAAW,GAEvC,GADe,EAAM,EAAI,KAAO,EAGlC,MAAO,GAGT,WAAwB,EAAM,EAAQ,CACpC,OAAS,GAAI,EAAO,OAAS,EAAG,GAAK,EAAG,IACtC,EAAK,KAAK,EAAO,IAEnB,MAAO,GAGT,WAAoB,EAAO,CACzB,KAAM,GAAkB,GAAI,aAAY,MAClC,EAAiB,GAAI,YAAW,MACtC,OAAS,GAAI,EAAG,GAAK,IAAK,IACxB,EAAgB,GAAK,KACrB,EAAe,GAAK,EAEtB,GAAI,GAAmB,IACnB,EAAa,EACb,EAAW,EAEf,YAA0B,CACxB,EAAmB,IACnB,EAAa,EAEf,WAAiB,EAAO,CACtB,KAAM,GAAO,EAAQ,EAAO,EAAU,GACtC,UAAY,EACL,EAET,WAAyB,EAAG,EAAG,CAC7B,SAAe,GAAoB,EACnC,EAAgB,GAAoB,EACpC,IACO,EAAmB,EAE5B,WAA+B,EAAG,CAChC,KAAM,GAAM,GACZ,OAAS,GAAI,EAAG,IAAM,KAAM,EAAI,EAAgB,GAC9C,EAAI,KAAK,EAAe,IAE1B,MAAO,GAGT,KAAM,GAAS,GACf,IACA,KAAM,GAAQ,GAAI,YAAW,GAC7B,GAAI,GAAO,EAAQ,GACf,EACJ,KAAO,IAAS,GAAU,CACxB,GAAI,IAAS,EAAY,CAGvB,IAFA,IACA,EAAO,EAAQ,GACR,IAAS,GACd,EAAO,EAAQ,GAGjB,GAAI,IAAS,EACX,MACK,GAAI,EAAO,EAChB,KAAM,IAAI,OAAM,8BAA8B,KACzC,CACL,KAAM,GAAM,EAAsB,GAClC,EAAe,EAAQ,GACvB,EAAU,WAEH,EAAO,EAAkB,CAClC,KAAM,GAAM,EAAsB,GAClC,EAAe,EAAQ,GACvB,EAAgB,EAAS,EAAI,EAAI,OAAS,IAC1C,EAAU,MACL,CACL,KAAM,GAAS,EAAsB,GACrC,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,mCAAmC,OAAa,gBAA+B,KAEjG,EAAe,EAAQ,GACvB,EAAO,KAAK,EAAO,EAAO,OAAS,IACnC,EAAgB,EAAS,EAAO,EAAO,OAAS,IAChD,EAAU,EAGZ,AAAI,EAAmB,GAAM,GAAK,GAChC,CAAI,IAAe,EACjB,EAAU,OAEV,KAGJ,EAAO,EAAQ,GAEjB,MAAO,IAAI,YAAW,GAGT,eAAyB,EAAY,CAClD,YAAY,EAAQ,CAClB,MAAO,GAAW,GAAe"}